"""Assignment 1 - Events (Task 2)

=== CSC148 Fall 2019 ===
Department of Computer Science,
University of Toronto

=== Module description ===
This module contains all of the classes necessary to model the different
kinds of events in the simulation.

This code is provided solely for the personal and private use of
students taking the CSC148 course at the University of Toronto.
Copying for purposes other than this use is expressly prohibited.
All forms of distribution of this code, whether as given or with
any changes, are expressly prohibited.

Author: Jacqueline Smith

All of the files in this directory and all subdirectories are:
Copyright (c) 2019 Jacqueline Smith
"""
from __future__ import annotations
from typing import List, TextIO
from store import GroceryStore, Customer, Item


class Event:
    """An event.

    Events have an ordering based on the event timestamp in non-ascending
    order. Events with older timestamps are greater than those with newer
    timestamps.

    This class is abstract; subclasses must implement do().

    YOU SHOULD NOT CHANGE THIS CLASS!

    === Attributes ===
    timestamp: A timestamp for this event.
    """
    timestamp: int

    def __init__(self, timestamp: int) -> None:
        """Initialize an Event with a given timestamp.

        Precondition: timestamp must be a non-negative integer.

        >>> Event(7).timestamp
        7
        """
        self.timestamp = timestamp

    # The following six 'magic methods' are overridden to allow for easy
    # comparison of Event instances. All comparisons simply perform the
    # same comparison on the 'timestamp' attribute of the two events.
    def __eq__(self, other: Event) -> bool:
        """Return whether this Event is equal to <other>.

        Two events are equal if they have the same timestamp.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first == second
        False
        >>> second.timestamp = first.timestamp
        >>> first == second
        True
        """
        return self.timestamp == other.timestamp

    def __ne__(self, other: Event) -> bool:
        """Return True iff this Event is not equal to <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first != second
        True
        >>> second.timestamp = first.timestamp
        >>> first != second
        False
        """
        return not self.__eq__(other)

    def __lt__(self, other: Event) -> bool:
        """Return True iff this Event is less than <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first < second
        True
        >>> second < first
        False
        """
        return self.timestamp < other.timestamp

    def __le__(self, other: Event) -> bool:
        """Return True iff this Event is less than or equal to <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first <= first
        True
        >>> first <= second
        True
        >>> second <= first
        False
        """
        return self.timestamp <= other.timestamp

    def __gt__(self, other: Event) -> bool:
        """Return True iff this Event is greater than <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first > second
        False
        >>> second > first
        True
        """
        return not self.__le__(other)

    def __ge__(self, other: Event) -> bool:
        """Return True iff this Event is greater than or equal to <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first >= first
        True
        >>> first >= second
        False
        >>> second >= first
        True
        """
        return not self.__lt__(other)

    def do(self, store: GroceryStore) -> List[Event]:
        """Return a list of events generated by performing this event.

        Call methods on <store> to update its state according to the
        meaning of the event. Note: the "business logic" of what actually
        happens inside a grocery store should be handled in the GroceryStore
        class, not in any Event classes.

        Return a list of new events spawned by this event (making sure the
        timestamps are correct).
        """
        raise NotImplementedError('Implemented in a subclass')


# TODO: Complete the subclasses for the different types of events below.
# You should use the provided attributes in your solution. However, if you need
# to, you may add private attributes and helper methods, but do not change the
# public interface.
# Write docstrings for all methods you write, and document your attributes
# in the class docstring.
class CustomerArrival(Event):
    """A customer arrives at the checkout area ready to check out.

    === Attributes ===
    customer: The arriving customer
    """
    customer: Customer

    def __init__(self, timestamp: int, c: Customer) -> None:
        """Initialize a CustomerArrival event with <timestamp> and customer <c>.
        """
        super().__init__(timestamp)
        self.customer = c

    def do(self, store: GroceryStore) -> List[Event]:
        """Return a list of events representing this customer joining a line in
        GroceryStore.

        A customer cannot join a line that does not have capacity for them.
        When there are no lines the customer can join, the “new customer”
        event should go back into the container, and have its timestamp
        increased by 1 (representing trying to join a line again at the
        next time interval.)

        If a new customer joins an empty checkout line, a new
        “begin checking out” event is added with the same timestamp
        as the join event.
        """
        line_entered = store.enter_line(self.customer)
        result = []
        marker = True
        while marker is True:
            if line_entered == -1:
                self.timestamp += 1
            else:
                event = CustomerArrival(self.timestamp, self.customer)
                result.append(event)
                marker = False
        return result

class CheckoutStarted(Event):
    """A customer starts the checkout process.

    Once the checkout process starts, the only way for the customer to leave
    the line is for a CheckoutCompleted event to occur.

    === Attributes ===
    line_number: The number of the checkout line.
    """
    line_number: int

    def __init__(self, timestamp: int, line_number: int) -> None:
        """Initialize a CheckoutStarted event with <timestamp> and
        <line_number>.
        """
        super().__init__(timestamp)
        self.line_number = line_number


    def do(self, store: GroceryStore) -> List[Event]:
        """Return an event representing when checkout will be completed

        If a customer begins checking out, a new “finish checking out” event is
        added with the same timestamp as the “begin” timestamp, plus the
        appropriate amount of time based on the type of checkout line and
        the time required by the customer’s items.
        """
        total_waiting_time = self.timestamp #should encompass wait time of entire queue
        for customer in store.get_line_list()[0].queue[:-1]:
            total_waiting_time += customer.get_item_time()

        event = CheckoutStarted(total_waiting_time, self.line_number)


    # create timestamp when checkout will be completed
    #emit the event


class CheckoutCompleted(Event):
    """A customer finishes the checkout process.

    A CheckoutCompleted event might occur after a line closes.

    === Attributes ===
    line_number: The number of the checkout line.
    customer: The finishing customer.
    """
    line_number: int
    customer: Customer

    def __init__(self, timestamp: int, line_number: int, c: Customer) -> None:
        """Initialize a CheckoutCompleted event with <timestamp>, <line_number>,
        and customer <c>.
        """
        super().__init__(timestamp)
        self.line_number = line_number
        self.customer = c


    def do(self, store: GroceryStore) ->:
        """
        If a customer finishes checking out, the next customer in the line
        (if there is one) gets a “begin checking out” event with the same
        timestamp as the “finish” event.
        Remove customer from the line
        """
        #remove them from the line
        # no events to emit?

class CloseLine(Event):
    """A CheckoutLine gets closed.

    === Attributes ===
    line_number: The number of the checkout line.
    """
    line_number: int

    def __init__(self, timestamp: int, line_number: int) -> None:
        """Initialize a CloseLine event with <timestamp> and <line_number>.
        """

    def do(self, store: GroceryStore):
        """
        If a line closes, there is one “new customer” event per customer in the
        checkout line after the first one. The new events should be spaced 1
        second apart, with the last customer in the line having the earliest
        “new customer” event, which is the same as the “line close” event.
        """



# TODO: Complete this function, which creates a list of events from a file.
def create_event_list(event_file: TextIO) -> List[Event]:
    """Return a list of Events based on raw list of events in <event_file>.

    Precondition: <event_file> is in the format specified by the assignment
    handout.
    """


if __name__ == '__main__':
    import doctest
    doctest.testmod()
    import python_ta
    python_ta.check_all(config={
        'allowed-import-modules': ['__future__', 'typing', 'store',
                                   'python_ta', 'doctest']})
